package errors

import (
	"fmt"
	"github.com/golang/glog"
	kerrors "k8s.io/apimachinery/pkg/api/errors"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/labels"
	"k8s.io/apimachinery/pkg/runtime/schema"
)

type KubeclientVerb string

const (
	KubeclientVerbCreate KubeclientVerb = "CREATE"
	KubeclientVerbGet    KubeclientVerb = "GET"
	KubeclientVerbUpdate KubeclientVerb = "UPDATE"
	KubeclientVerbDelete KubeclientVerb = "DELETE"
	KubeclientVerbPatch  KubeclientVerb = "PATCH"
)

type KubeclientError struct {
	verb KubeclientVerb
	gvk  schema.GroupVersionKind
	ns   string
	name string
	err  error
}

func (e KubeclientError) Error() string {
	return fmt.Sprintf(
		"failed to %s %s '%s/%s': %s", e.verb, e.gvk.Kind,
		e.ns, e.name, e.err)
}

// ShouldRetry determines if the error generated by an API call will be
// retried. It follows API conventions stipulated by
// https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md#http-status-codes
func (e KubeclientError) ShouldRetry() bool {
	switch kerrors.ReasonForError(e.err) {
	case metav1.StatusReasonBadRequest,
		metav1.StatusReasonForbidden,
		metav1.StatusReasonNotFound,
		metav1.StatusReasonMethodNotAllowed,
		metav1.StatusReasonGone,
		metav1.StatusReasonInvalid:
		return false

	case metav1.StatusReasonUnauthorized,
		metav1.StatusReasonConflict,
		metav1.StatusReasonTooManyRequests,
		metav1.StatusReasonInternalError,
		metav1.StatusReasonServiceUnavailable,
		metav1.StatusReasonServerTimeout:
		return true
	}

	glog.V(8).Infof("Cannot determine reason for error %#v, will assume it's retriable", e)
	return true
}

func (e KubeclientError) ShouldBroadcast() bool {
	return !kerrors.IsConflict(e.err)
}

type kubeobj interface {
	GetName() string
	GetNamespace() string
	GroupVersionKind() schema.GroupVersionKind
}

func NewKubeclientErrorFromObject(verb KubeclientVerb, obj kubeobj, err error) KubeclientError {
	return NewKubeclientError(verb, obj.GroupVersionKind(),
		obj.GetNamespace(), obj.GetName(), err)
}

func NewKubeclientError(verb KubeclientVerb, gvk schema.GroupVersionKind, ns, name string, err error) KubeclientError {
	return KubeclientError{
		verb: verb,
		gvk:  gvk,
		ns:   ns,
		name: name,
		err:  err,
	}
}

func NewKubeclientGetError(gvk schema.GroupVersionKind, ns, name string, err error) KubeclientError {
	return NewKubeclientError(KubeclientVerbGet, gvk, ns, name, err)
}

func NewKubeclientDeleteError(gvk schema.GroupVersionKind, ns, name string, err error) KubeclientError {
	return NewKubeclientError(KubeclientVerbDelete, gvk, ns, name, err)
}

func NewKubeclientPatchError(gvk schema.GroupVersionKind, ns, name string, err error) KubeclientError {
	return NewKubeclientError(KubeclientVerbPatch, gvk, ns, name, err)
}

func NewKubeclientUpdateError(obj kubeobj, err error) KubeclientError {
	return NewKubeclientErrorFromObject(KubeclientVerbUpdate, obj, err)
}

func NewKubeclientCreateError(obj kubeobj, err error) KubeclientError {
	return NewKubeclientErrorFromObject(KubeclientVerbCreate, obj, err)
}

type KubeclientListError struct {
	gvk      schema.GroupVersionKind
	ns       string
	selector labels.Selector
	err      error
}

func (e KubeclientListError) Error() string {
	return fmt.Sprintf("failed to list %s in namespace %q using selector %q: %s",
		e.gvk.Kind, e.ns, e.selector.String(), e.err.Error())
}

func (e KubeclientListError) ShouldRetry() bool {
	return true
}

func NewKubeclientListError(gvk schema.GroupVersionKind, ns string, selector labels.Selector, err error) error {
	return KubeclientListError{
		ns:       ns,
		gvk:      gvk,
		selector: selector,
		err:      err,
	}
}

func IsKubeclientError(err error) bool {
	switch err.(type) {
	case KubeclientError, KubeclientListError:
		return true
	}

	return false
}
